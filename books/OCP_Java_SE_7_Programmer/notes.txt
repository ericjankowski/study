OCA/OCP Java SE 7 Programmer 1 & 2 Study Guide (Exams 1Z0-803 & 1Z0-804)
========================================================================

Preface
-------

Dont skip the Appendices.  Appendix A in particular covers serialization.

In Every Chapter
	- Certification Objectives
	- Exam Watch
	- On the Job
	- Exercises
	- From the Classroom
	- Certification Summary
	- Two-Minute Drill
	- Self Test - take the self tests after completing each chapter in order to reinforce what you've learned and become familiar with the structure of the exam questions


Introduction
------------

Organization
	- Practice Exams are abailable for download see Appendix C

What this book is not
	- Even the most experienced Java developers often clain that having to prepare for the certigication exam made them far more knowledgeable and well-rounded programmers than they would have been without the exam-driven studying.

Some Pointers
	1.  Re-read all the Two-Minute Drills, or have someone quiz you.
	2.  Re-read all the Exam Watch notes.
	3.  Re-take the Self Tests
	4.  Complete the exercises
	5.  Write lots of Java code
		- Put away your IDE, crank up the command line, and write code!

Introduction to the Material in the Book

Who Cares About Certification?


Chapter 1 - Declarations and Access Control
-------------------------------------------

Delcaring Interface Constants
	- Interfaces can have constants
	- They are ALWAYS public static final, but they don't have to be declared that way
	- Any combination of the required, but implicit, modifiers is legal, as is using no modifiers at all

Access Modifiers
	- 4 access modifiers
		- public
		- protected
		- default
		- private

Public Members

Private Members
	- private methods are not inherited by sub-classes.
		- Therefore, they can not be overridden

Protected and Default Members
	- A default member may only be accessed if the class accessing the member belongs to the same package, whereas a protected member can be accessed (through inheritance) by a subclass even if the subclass is in a different package.
	- Default and protected behavior differ only when we talk about subclasses.
	- default = package
	- protected = package + kids

Protected Details
	- subclass-outside-the-package - protected members are not visible to "neighbors" in the same package as the subclass

Default Details
	- subclasses outside the package do not inherit default members

Any local variable declared with an access modifier will not compile

Table: Determining access to class members

Visibility									| Public 	| Protected 	| Default 	| Private
----------------------------------------------------------------------------------------------
From the same class 						| Yes		| Yes			| Yes		| Yes
----------------------------------------------------------------------------------------------
From any class in the same package 			| Yes		| Yes			| Yes		| No
----------------------------------------------------------------------------------------------
From a subclass in the same package 		| Yes		| Yes			| Yes		| No
----------------------------------------------------------------------------------------------
From a subclass outside the same package 	| Yes 		| Yes (inherit)	| No 		| No 	
----------------------------------------------------------------------------------------------
From any non-subclass outside the package 	| Yes		| No 			| No 		| No


Nonaccess Member Modifiers

Final Methods
	- The final keyword prevents a method from being overridden in a subclass

Final Arguments
	- Method arguments are essentially the same as local variables
	- A final method argument can not be modified within the method

Abstract Methods

Synchronized Methods
	- The synchronized keyword indicates that a method can be accessed by only one thread at a time.

Native Methods
	- The native modifier indicates that a method is implemented in platform-dependent code, often in C.
	- 'native' can be applied only to methods, not classes or variables
	- The body of a native method must be a semicolon, indicating that the implementation is omitted

Strictfp Methods
	- strictfp can be applied to both classes and methods, not variables
	- The strictfp modifier forces floating points and any floating-point operations to adhere to the IEEE 754 standard.
	- With strictfp, you can predict how your floating points will behave regardless of the underlying platform the JVM is running on.
	- A variable can never be declared strictfp

Methods with Variable Argument Lists (var-args)
	- Syntax
		- Legal
			- void doStuff(int... x){}
			- void doStuff2(char c, int... x){}
			- void doStuff2(Animal... animal){}
		- Illegal
			- void doStuff4(int x...){} 			//bad syntax
			- void doStuff5(int... x, char... y)	//too many var-args
			- void doStuff6(String... s, byte b)	//var-arg must be last

Constructor Declarations
	- Constructors never have a return type
	- Syntax
		- Legal
			- Foo(){}
			- private Foo(){}
			- Foo(int x){}
			- Foo(int x, int... y){}
		- Illegal
			- void Foo(){}			//this is a method, not a constructor
			- Foo2(){}				//this is not a method or a constructor
			- Foo(short s);			//this looks like an abstract method
			- static Foo(float f){}	//constructors can not be static
			- final Foo(long x){}	//constructors can not be final
			- abstract Foo(char c)	//constructors can not be abstract
			- Foo(int... x, int t)	//bad var-arg syntax

Variable Declarations
	- Primitives - one of eight types: char, boolean, byte, short, int, long, double, float
	- Reference variables - used to refer to an object

Declaring Primitives and Primitive Ranges
	- integer types from small to big
		- byte 	(1 byte)
		- short	(2 bytes)
		- int 	(4 bytes)
		- long	(8 bytes)
	- doubles (8 bytes) are bigger than floats (4 bytes)
	- all the number types are signed
		- the leftmost bit (the most significant digit) is used to represent the sign
		- the rest of the bits represent the value, using two's complement notation
	- The char type contains a single, 16-bit Unicode character

Declaring Reference Variables

Instance Variables
	- Instance variables are defined inside the class, but outside of any method
	- Instance variables are initialized only when the class is instantiated

Local (Automatic/Stack/Method) Variables
	- Local variables are always ont the stack, not the heap.
	- While the local variable is on the stack, if the variable is an object reference, the object itself will still be created on the heap.  There is no such thing as a stack object, only a stack variable.
	- Unlike instance variables, local variables don't get default values.
	- Use the 'this' keyword to increase readability and avoid name collision confusion

Array Declarations
	- Arrays will always be an object on the heap, even if the array is declared to hold primitive elements.
	- There is not such thing as a primitive array, but you can make an array of primitives
	- It is never legal to include the size of the array in its declaration
		- int[5] scores;  // illegal, the JVM doesn't allocate space until you actually instantiate the array object.

Final Variables
	- Declaring a variable with the final keyword makes it impossible to reassign that variable once it has been initialized with an explicit value.
	- A reference variable marked final can't ever be reassigned to refer to a different object, but the data withini the object can still be modified.
	- There are no final objects, only final references

Transient Variables
	- When you mark a variable transient, you are telling the JVM to skip this variable when you attempt to serialize the object containing it.

Volatile Variables
	- The volatile midifier tells the JVM that a thread accessing the variable must always reconcile its own private copy of the variable with the master copy in memory.
	- The volatile keyword can only be applied to instance variables

Static Variable and Methods

Declaring enums
	- appeared in Java 5
	- enums can not be declared in methods
	- Syntax
		- enum CoffeeSize { BIG, HUGE, OVERWHELMING };
		- CoffeSize cs = CoffeeSize.BIG;

Declaring Constructors, Methods, and Variables in an enum
	- Constant-specific class body - for when you want to override a particular method of the grander enum for a specific enum type



Chapter 2 - Object Orientation
------------------------------

Vocabulary
	- inheritance
	- polymorphism
	- encapsulation
	- coupling
	- cohesion
	- composition
	- design patterns

Encapsulation
	- Encapsulation should promote flexibility and maintainability
	- Public instance variables expose too much of your class's internal structure.
		- This decreases the flexibility of the class to change later.
	- Encapsulation gives you the ability to make changes in your implementation without breaking compatibility with clients.
	- Hide implementation details behind a public programming interface.
	- Tha advantage of getters and setters is that they provide the ability to change your mind later, go back and add more code to your methods without braking your API.
	- Good OO design dictates that you should plan for the future.

Inheritance and Polymorphism
	- The two most common reasons to use inheritance are
		- to promote code reuse
		- to use polymorphism

Is-A and Has-A Relationships
	Is-A
		- Interface or Inheritance
	Has-A
		- Based on usage, rather than inheritance

Polymorphism

Overriding / Overloading

Overridden Methods
	- Overriding methods can not have a more restrictive access modifier than the method being overridden

Invoking a Superclass Version of an Overridden Method
	- super.overriddenMethod();  //legal
	- super.super.overriddenMethod();  //illegal

Overloaded Methods
	- The choice of which overloaded method to call is NOT dynamically decided at runtime
		- The reference type, not the object type, determines which overloaded method is invoked.
	- The main method can be overloaded, but "the only main() with JVM superpowers" is the main(String[] args) method

Casting
	- Downcasting is explicitly trying to cast an object to a more specific object down the inheritance tree
		- Example:

		  Animal animal = new Dog();
		  if (animal instanceof Dog){
		  	Dog dog = (Dog) animal;
		  }

		 - Compiler is trusting that we know what we are doing.  
		 	- If we screw it up a little, we might get a ClassCastException at runtime (Downcasting within an inheritance tree)
		 	- If we screw it up a lot, will ge an inconvertible types compiler error (Casting to an unrelated object - not in the inheritance tree).

	- Upcasting just works.  No need for the (Cast) operation.
		- Example:

		  Object object = new Animal();

Implementing an Interface

Legal Return Types

Return Type Declarations

Return Types on Overloaded Methods
	Illegal:

		public class Foo{
			void go(){}
		}
		public class Bar extends Foo{
			String go(){ 	// Not legal! Can't change only the returh type
				return null;
			}
		}

	Legal:
		public class Foo{
			void go(){}
		}
		public class Bar extends Foo{
			String go(int i){}  // Legal, this is an overloaded method with a new return type, basically a totally new method
		}

Overriding and Return Types
	"Covariant Return" example (legal):

		class Alpha {
			Alpha doStuff(char c){
				return new Alpha();
			}
		}
		class Beta extends Alpha {
			Beta doStuff(char c){
				return new Alpha();
			}
		}

Returning a Value

Constructors and Instantiation

Constructor Basics
	- Constructors do not have return types
	- Constructors' names must exactly match the class name
	- It is very common and desirable for a class to have a no-arg constructor
	- Constructors can be overloaded

Constructor Chaining
	- Every constructor IMPLICITLY calls super() before executing it's body.

Rules for Constructors
	- Constructors can use any access modifier
	- The constructor name must match the name of the class
	- Constructors must not have a return type
	- A method with a return type and the same name as the class is just a method.  It's not a constructor.
	- The default constructor is always the no-arg constructor
	- If a class has implemented a constructor with arguments, the compilier will not provide the default, no-arg constructor

Determine Whether a Default Constructor Will Be Created
	- If your immediate parent does not have a no-arg constructor, you must type in the call to super(), supplying the appropriate arguments.
	- Constructors are not inherited

Overloaded Constructors
	- You can call static methods in a constructor
	- A constructor can never have both a call to this() and super()

Initialization Blocks
	- static init block - runs once, when the class is first loaded
	- instance init block - runs once every time a new instance is created, right after the call to super().
	- If you have more than one block of any kind, order matters

Static Variables and Methods

Accessing Static Methods and Variables


Chapter 3 - Assignments
-----------------------

Stack and Heap - Quick Review
	- Instance variables and objects live on the heap.
	- Local variables live on the stack

Literals, Assignments, and Variables

Literal Values for All Primitive Typers

Integer Literals (longs also)
	- 4 ways to represent integers - decimal (base 10), octal (base 8), hexadecimal (base 16), binary (base 2 - new feature in Java 7)
	- Numeric Literal with Underscores
		- You cannot use the underscore literal at the beginning or end of the literal
	- Decimal Literals (base 10)
	- Binary Literals (base 2)
		- int b1 = 0B101010; // set b1 to binary 101010 (decimal 42)
		- int b2 = 0b00011;  // set b2 to binary 11 (decimal 3)
		- long b3 = 0b00011l;
	- Octal Literals
		- int o1 = 06;  // set o1 to octal 6 (decimal 6)
		- int o2 = 011; // set o2 to octal 11 (decimal 9)
	- Hexadecimal Literals
		- int x1 = 0X0001;  // set x1 to hexadecimal 1 (decimal 1)
		- int x2 = 0x7fffffff; //set x2 to hexadecimal 7fffffff (decimal 2147483647)

Floating-point Literals
	- defined as double (64 bits) by default.
	- if you want a true floating point literal, you need the f/F suffix
		- float f1 = 12.12f
		- float f2 = 23.23F

Boolean Literals
	- Numbers CANNOT be used as boolean literals
		- boolean b1 = 0; // results in a compiler error
		- in x = 1; if (x) {} // results in a compiler error

Character Literals
	- A char literal is represented by a single character in single quotes
		- char a = 'a';
		- char b = '@';
	- Unicode values are allowed
		- char letterN = '\u004E'
	- Characters are 16-bit unsigned integers under the hood, so you can use any integer literal as well.  Some expressions will need a cast

String Literals

Assignment Operators

Primitive Assignments

Primitive Casting

Assigning Floating-point Numbers
	- you have to be explicit with float literals
		- float f = (float) 32.3;
		- float g = 32.3f
		- float h = 32.3F

Assigning a Literal That is Too Large for the Variable

Assigning One Primitive Variable to Another Primitive Variable

Variable Scope

Variable Initialization

Using a Variable or Array Element That is Uninitialized and Unassigned

Primitive and Object Tupe Instance Variables

Primitive Instance Variables

Object Reference Instance Variables

Array Instance Variables

Local Primitives and Objects
	- must be initialized before use, otherwise the compiler errors out

Local Object References

Local Arrays

Assigning One Reference Variable to Another
	- Primitives are passed by value
	- Objects are passed by reference
	- Strings are a little more like primitives than objects

Passing Variables int Methods

Passing Object Reference Variables

Passing Primitive Variables

Garbage Collection

Overview of Memory Management and Garbage Collection
	- It is estimated that manual memory management can double the development effort for a complex program

Overview of Java's Garbage Collector

When does the garbage collector run?
	- The JVM decides when to run the garbage collector
	- Experience indicates that when your Java program makes a request for garbage collection, the JVM will usually grant your request in short order, but there are no guarantees

How does the Garbage Collector Work?
	- An object is eligible for garbage collection when no live thread can access it.

Writing Code the Explicitly Makes Objects Eligible for Collection

Nulling a Reference

Reassigning a Reference Variable