OCA/OCP Java SE 7 Programmer 1 & 2 Study Guide (Exams 1Z0-803 & 1Z0-804)
========================================================================

Preface
-------

Dont skip the Appendices.  Appendix A in particular covers serialization.

In Every Chapter
	- Certification Objectives
	- Exam Watch
	- On the Job
	- Exercises
	- From the Classroom
	- Certification Summary
	- Two-Minute Drill
	- Self Test - take the self tests after completing each chapter in order to reinforce what you've learned and become familiar with the structure of the exam questions


Introduction
------------

Organization
	- Practice Exams are abailable for download see Appendix C

What this book is not
	- Even the most experienced Java developers often clain that having to prepare for the certigication exam made them far more knowledgeable and well-rounded programmers than they would have been without the exam-driven studying.

Some Pointers
	1.  Re-read all the Two-Minute Drills, or have someone quiz you.
	2.  Re-read all the Exam Watch notes.
	3.  Re-take the Self Tests
	4.  Complete the exercises
	5.  Write lots of Java code
		- Put away your IDE, crank up the command line, and write code!

Introduction to the Material in the Book

Who Cares About Certification?


Chapter 1 - Declarations and Access Control
-------------------------------------------

Delcaring Interface Constants
	- Interfaces can have constants
	- They are ALWAYS public static final, but they don't have to be declared that way
	- Any combination of the required, but implicit, modifiers is legal, as is using no modifiers at all

Access Modifiers
	- 4 access modifiers
		- public
		- protected
		- default
		- private

Public Members

Private Members
	- private methods are not inherited by sub-classes.
		- Therefore, they can not be overridden

Protected and Default Members
	- A default member may only be accessed if the class accessing the member belongs to the same package, whereas a protected member can be accessed (through inheritance) by a subclass even if the subclass is in a different package.
	- Default and protected behavior differ only when we talk about subclasses.
	- default = package
	- protected = package + kids

Protected Details
	- subclass-outside-the-package - protected members are not visible to "neighbors" in the same package as the subclass

Default Details
	- subclasses outside the package do not inherit default members

Any local variable declared with an access modifier will not compile

Table: Determining access to class members

Visibility									| Public 	| Protected 	| Default 	| Private
----------------------------------------------------------------------------------------------
From the same class 						| Yes		| Yes			| Yes		| Yes
----------------------------------------------------------------------------------------------
From any class in the same package 			| Yes		| Yes			| Yes		| No
----------------------------------------------------------------------------------------------
From a subclass in the same package 		| Yes		| Yes			| Yes		| No
----------------------------------------------------------------------------------------------
From a subclass outside the same package 	| Yes 		| Yes (inherit)	| No 		| No 	
----------------------------------------------------------------------------------------------
From any non-subclass outside the package 	| Yes		| No 			| No 		| No


Nonaccess Member Modifiers

Final Methods
	- The final keyword prevents a method from being overridden in a subclass

Final Arguments
	- Method arguments are essentially the same as local variables
	- A final method argument can not be modified within the method

Abstract Methods

Synchronized Methods
	- The synchronized keyword indicates that a method can be accessed by only one thread at a time.

Native Methods
	- The native modifier indicates that a method is implemented in platform-dependent code, often in C.
	- 'native' can be applied only to methods, not classes or variables
	- The body of a native method must be a semicolon, indicating that the implementation is omitted

Strictfp Methods
	- strictfp can be applied to both classes and methods, not variables
	- The strictfp modifier forces floating points and any floating-point operations to adhere to the IEEE 754 standard.
	- With strictfp, you can predict how your floating points will behave regardless of the underlying platform the JVM is running on.
	- A variable can never be declared strictfp

Methods with Variable Argument Lists (var-args)
	- Syntax
		- Legal
			- void doStuff(int... x){}
			- void doStuff2(char c, int... x){}
			- void doStuff2(Animal... animal){}
		- Illegal
			- void doStuff4(int x...){} 			//bad syntax
			- void doStuff5(int... x, char... y)	//too many var-args
			- void doStuff6(String... s, byte b)	//var-arg must be last

Constructor Declarations
	- Constructors never have a return type
	- Syntax
		- Legal
			- Foo(){}
			- private Foo(){}
			- Foo(int x){}
			- Foo(int x, int... y){}
		- Illegal
			- void Foo(){}			//this is a method, not a constructor
			- Foo2(){}				//this is not a method or a constructor
			- Foo(short s);			//this looks like an abstract method
			- static Foo(float f){}	//constructors can not be static
			- final Foo(long x){}	//constructors can not be final
			- abstract Foo(char c)	//constructors can not be abstract
			- Foo(int... x, int t)	//bad var-arg syntax

Variable Declarations
	- Primitives - one of eight types: char, boolean, byte, short, int, long, double, float
	- Reference variables - used to refer to an object

Declaring Primitives and Primitive Ranges
	- integer types from small to big
		- byte 	(1 byte)
		- short	(2 bytes)
		- int 	(4 bytes)
		- long	(8 bytes)
	- doubles (8 bytes) are bigger than floats (4 bytes)
	- all the number types are signed
		- the leftmost bit (the most significant digit) is used to represent the sign
		- the rest of the bits represent the value, using two's complement notation
	- The char type contains a single, 16-bit Unicode character

Declaring Reference Variables

Instance Variables
	- Instance variables are defined inside the class, but outside of any method
	- Instance variables are initialized only when the class is instantiated

Local (Automatic/Stack/Method) Variables
	- Local variables are always ont the stack, not the heap.
	- While the local variable is on the stack, if the variable is an object reference, the object itself will still be created on the heap.  There is no such thing as a stack object, only a stack variable.
	- Unlike instance variables, local variables don't get default values.
	- Use the 'this' keyword to increase readability and avoid name collision confusion

Array Declarations
	- Arrays will always be an object on the heap, even if the array is declared to hold primitive elements.
	- There is not such thing as a primitive array, but you can make an array of primitives
	- It is never legal to include the size of the array in its declaration
		- int[5] scores;  // illegal, the JVM doesn't allocate space until you actually instantiate the array object.

Final Variables
	- Declaring a variable with the final keyword makes it impossible to reassign that variable once it has been initialized with an explicit value.
	- A reference variable marked final can't ever be reassigned to refer to a different object, but the data withini the object can still be modified.
	- There are no final objects, only final references

Transient Variables
	- When you mark a variable transient, you are telling the JVM to skip this variable when you attempt to serialize the object containing it.

Volatile Variables
	- The volatile midifier tells the JVM that a thread accessing the variable must always reconcile its own private copy of the variable with the master copy in memory.
	- The volatile keyword can only be applied to instance variables

Static Variable and Methods

Declaring enums
	- appeared in Java 5
	- enums can not be declared in methods
	- Syntax
		- enum CoffeeSize { BIG, HUGE, OVERWHELMING };
		- CoffeSize cs = CoffeeSize.BIG;

Declaring Constructors, Methods, and Variables in an enum
	- Constant-specific class body - for when you want to override a particular method of the grander enum for a specific enum type



Chapter 2 - Object Orientation
------------------------------

Vocabulary
	- inheritance
	- polymorphism
	- encapsulation
	- coupling
	- cohesion
	- composition
	- design patterns

Encapsulation
	- Encapsulation should promote flexibility and maintainability
	- Public instance variables expose too much of your class's internal structure.
		- This decreases the flexibility of the class to change later.
	- Encapsulation gives you the ability to make changes in your implementation without breaking compatibility with clients.
	- Hide implementation details behind a public programming interface.
	- Tha advantage of getters and setters is that they provide the ability to change your mind later, go back and add more code to your methods without braking your API.
	- Good OO design dictates that you should plan for the future.

Inheritance and Polymorphism
	- The two most common reasons to use inheritance are
		- to promote code reuse
		- to use polymorphism

Is-A and Has-A Relationships
	Is-A
		- Interface or Inheritance
	Has-A
		- Based on usage, rather than inheritance

Polymorphism

Overriding / Overloading

Overridden Methods
	- Overriding methods can not have a more restrictive access modifier than the method being overridden

Invoking a Superclass Version of an Overridden Method
	- super.overriddenMethod();  //legal
	- super.super.overriddenMethod();  //illegal

Overloaded Methods

